# 징검다리 건너기 (large)

- 문제: https://www.acmicpc.net/problem/22871

## 시도 1: 실패

### 완전탐색..?

5개의 돌이 있을 때, 1번 돌 -> 5번 돌로 가는 과정은 아래와 같을 것이다.

- 0번 거쳐서 가기: 1가지 경우
- 1번 거쳐서 가기: 3가지 경우 (1->2->5, 1->3->5, 1->4->5)
- 2번 거쳐서 가기: 6가지 경우
- 3번 거쳐서 가기: 6가지 경우
- 4번 거쳐서 가기: 3가지 경우
- 5번 거쳐서 가기: 1가지 경우

그러나, 이를 완전탐색으로 푼다면 모든 가능한 경우의 수를 고려하기 때문에 매우 비효율적이다.
각 돌을 거치거나 거치지 않는 2가지 선택지가 있고, 돌의 개수에 따라 경우의 수가 지수적으로 증가한하게 된다.
따라서 돌의 개수를 n이라고 할 때, 경우의 수는 2^n 개가 되므로, O(2^n)의 시간복잡도를 가지게 된다.

### dp..!

위 같은 이유로 n이 큰 경우에는 완전탐색으로 푸는 것은 매우 비효율적이며, dp와 같은 최적화 기법을 사용하여 시간 복잡도를 효과적으로 줄이는 것이 필요해보였다.

따라서 점화식을 세우기 시작했다.

```py
dp[i] = min(dp[i - 1], (i - 1) * (1 + abs(dp[i] - dp[1]))) # 틀림ㅎ
```

생각해보니, 2가지를 더 고려해야 했다.

1. 각 경우마다, K의 최댓값을 구해야 한다.
2. (i - 1) 뿐만 아니라, (i - 2), (i - 3), .., (i - j) 도 비교해봐야 한다.

답을 보기로 결정했다^^..

## 시도 2: dp -> 성공

> 답 참고.

```py
n = read_int()
stones = read_int_array()

dp = [0] + [INF] * (n - 1)

for i in range(1, n):
    for j in range(0, i):
        power = max((i - j) * (1 + abs(stones[i] - stones[j])), dp[j])
        dp[i] = min(dp[i], power)

print(dp[-1])
```

### 설명

1. i보다 인덱스가 작은 j에 대해서 j번째 돌을 밟고 i번째 돌로 오는 경우를 고려한다.
2. 이때 드는 최소 파워는 j에서 i로 이동하는 파워와 dp[j] (0에서 j번째 돌까지 오는데 드는 최소 파워) 중에서 더 큰 값이 된다.
3. 이렇게 모든 j에 대해서 최소 파워를 계산하고, 그 중에서 가장 작은 값을 dp[i]에 저장한다.

이렇게 하면 dp[i]는 첫 번째 돌에서 i번째 돌까지 가는데 필요한 최소 파워가 된다.

## 시도 3: 이분탐색

그러나 이 문제는 이분탐색을 학습하기 위해 선정한 문제였다..
따라서 이분 탐색으로도 풀어봐야겠다..!
TODO
